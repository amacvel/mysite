# Primera aplicación con Django

## Parte 1: Solicitudes y respuestas.

Para comprobar que Django está instalado y que versión ejecutando:

~~~
python -m django --version 
~~~

### Creando un proyecto.

~~~
django-admin startproject mysite
~~~

Esto creará el directorio/proyecto mysite en la ruta que nos encontremos.

### El servidor de desarrollo.

Verificamos que el proyecto Django funciona desde el directorio raíz:

~~~
python manage.py runserver
~~~

Visitamos http://127.0.0.1:8000 para comprobarlo.

### Creando la aplicación Encuestas.

Para crear la aplicación, nos aseguramos de estar en el mismo directorio que **manage.py** y ejecutamos:

~~~
python manage.py startapp polls
~~~

#### Nuestra primera vista.

Abrimos el archivo **polls/views.py** y colocamos el siguiente código:

~~~
from django.http import HttpResponse


def index(request):
    return HttpResponse("Hello, world. You're at the polls index.")
~~~

Debemos asignarla a una URL, y para esto necesitamos una URLconf. En el directorio polls, creamos un nuevo archivo llamado **urls.py** que incluirá el siguiente código:

~~~
from django.urls import path

from . import views

urlpatterns = [
    path("", views.index, name="index"),
]
~~~

El siguiente paso es apuntar la raíz URLconf al **polls/urls.py**. En **mysite/urls.py**, importamos include e insertamos include() en la urlpatterns, por lo que tenemos:

~~~
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path("polls/", include("polls.urls")),
    path("admin/", admin.site.urls),
]
~~~

Iniciamos el servidor y accedemos a http://localhost:8000/polls. Deberíamos ver el texto ("Hola, mundo") que definimos en la vista anterior.

## Parte 2: Modelos y el sitio de administración.

### Configuración de la base de datos.

Abrimos **mysite/settings.py**. De forma predeterminada, la configuración utiliza SQLite. Establecemos nuestra zona horaria a:

~~~
TIME_ZONE = 'Atlantic/Canary'
~~~

**INSTALLED_APPS** contiene los nombres de todas las aplicaciones que están activadas en esta instancia de Django.

Algunas de estas aplicaciones utilizan al menos una tabla de la base de datos, por lo que debemos crearlas antes de poder usarlas. Ejecutamos el siguiente comando:

~~~
python manage.py migrate
~~~

### Creando modelos.

En nuestra aplicación de encuentas, crearemos dos modelos: **Question** y **Choice**. Editamos el **polls/models.py**:

~~~
from django.db import models


class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField("date published")


class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)
~~~

### Activando modelos.

Para incluir la aplicación 'polls' a nuestro proyecto debemos agregar una referencia. Editamos **mysite/settings.py** y añadimos la ruta punteada en **INSTALLED_APPS**. Se verá tal que así:

~~~
INSTALLED_APPS = [
    "polls.apps.PollsConfig",
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
]
~~~

Ejecutamos otro comando:

~~~
python manage.py makemigrations polls
~~~

Deberíamos ver algo similar a lo siguiente:

~~~
Migrations for 'polls':
  polls/migrations/0001_initial.py
    - Create model Question
    - Create model Choice
~~~

Al ejecutar makemigrations, le estamos diciendo a Django que hemos realizado algunos cambios en sus modelos (en este caso, hemos realizado otros nuevos) y que desea que los cambios se almacenen como una migración.

El comando sqlmigrate toma nombres de migración y devuelve su SQL:

~~~
python manage.py sqlmigrate polls 0001
~~~

Deberíamos ver algo similar a lo siguiente:

~~~
BEGIN;
--
-- Create model Question
--
CREATE TABLE "polls_question" (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "question_text" varchar(200) NOT NULL,
    "pub_date" timestamp with time zone NOT NULL
);
--
-- Create model Choice
--
CREATE TABLE "polls_choice" (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "choice_text" varchar(200) NOT NULL,
    "votes" integer NOT NULL,
    "question_id" bigint NOT NULL
);
ALTER TABLE "polls_choice"
  ADD CONSTRAINT "polls_choice_question_id_c5b4b260_fk_polls_question_id"
    FOREIGN KEY ("question_id")
    REFERENCES "polls_question" ("id")
    DEFERRABLE INITIALLY DEFERRED;
CREATE INDEX "polls_choice_question_id_c5b4b260" ON "polls_choice" ("question_id");

COMMIT;
~~~

Ahora, volvemos a ejecutar migrate para crear las tablas modelo en la base de datos:

~~~
python manage.py migrate
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, polls, sessions
Running migrations:
  Rendering model states... DONE
  Applying polls.0001_initial... OK
~~~

Resumen de los tres pasos para realizar cambios en el modelo:
- Cambios en los modelos (en **models.py**).
- Ejecutar para crear migraciones para esos cambios **python manage.py makemigrations**
- Ejecutar para aplicar esos cambios a la base de datos **python manage.py migrate**

### Jugando con la API.

Invocamos el shell de Python:

~~~
python manage.py shell
~~~

~~~
>>> from polls.models import Choice, Question  # Import the model classes we just wrote.

# No questions are in the system yet.
>>> Question.objects.all()
<QuerySet []>

# Create a new Question.
# Support for time zones is enabled in the default settings file, so
# Django expects a datetime with tzinfo for pub_date. Use timezone.now()
# instead of datetime.datetime.now() and it will do the right thing.
>>> from django.utils import timezone
>>> q = Question(question_text="What's new?", pub_date=timezone.now())

# Save the object into the database. You have to call save() explicitly.
>>> q.save()

# Now it has an ID.
>>> q.id
1

# Access model field values via Python attributes.
>>> q.question_text
"What's new?"
>>> q.pub_date
datetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=datetime.timezone.utc)

# Change values by changing the attributes, then calling save().
>>> q.question_text = "What's up?"
>>> q.save()

# objects.all() displays all the questions in the database.
>>> Question.objects.all()
<QuerySet [<Question: Question object (1)>]>
~~~

No es una representación útil de este objeto. Editaremos el modelo y agregaremos un método a ambos en **polls/models.py**:

~~~
from django.db import models


class Question(models.Model):
    # ...
    def __str__(self):
        return self.question_text


class Choice(models.Model):
    # ...
    def __str__(self):
        return self.choice_text
~~~

Agregamos también un método personalizado a este modelo:

~~~
import datetime

from django.db import models
from django.utils import timezone


class Question(models.Model):
    # ...
    def was_published_recently(self):
        return self.pub_date >= timezone.now() - datetime.timedelta(days=1)
~~~

Guardamos los cambios e iniciamos un nuevo shell:

~~~
>>> from polls.models import Choice, Question

# Make sure our __str__() addition worked.
>>> Question.objects.all()
<QuerySet [<Question: What's up?>]>

# Django provides a rich database lookup API that's entirely driven by
# keyword arguments.
>>> Question.objects.filter(id=1)
<QuerySet [<Question: What's up?>]>
>>> Question.objects.filter(question_text__startswith="What")
<QuerySet [<Question: What's up?>]>

# Get the question that was published this year.
>>> from django.utils import timezone
>>> current_year = timezone.now().year
>>> Question.objects.get(pub_date__year=current_year)
<Question: What's up?>

# Request an ID that doesn't exist, this will raise an exception.
>>> Question.objects.get(id=2)
Traceback (most recent call last):
    ...
DoesNotExist: Question matching query does not exist.

# Lookup by a primary key is the most common case, so Django provides a
# shortcut for primary-key exact lookups.
# The following is identical to Question.objects.get(id=1).
>>> Question.objects.get(pk=1)
<Question: What's up?>

# Make sure our custom method worked.
>>> q = Question.objects.get(pk=1)
>>> q.was_published_recently()
True

# Give the Question a couple of Choices. The create call constructs a new
# Choice object, does the INSERT statement, adds the choice to the set
# of available choices and returns the new Choice object. Django creates
# a set to hold the "other side" of a ForeignKey relation
# (e.g. a question's choice) which can be accessed via the API.
>>> q = Question.objects.get(pk=1)

# Display any choices from the related object set -- none so far.
>>> q.choice_set.all()
<QuerySet []>

# Create three choices.
>>> q.choice_set.create(choice_text="Not much", votes=0)
<Choice: Not much>
>>> q.choice_set.create(choice_text="The sky", votes=0)
<Choice: The sky>
>>> c = q.choice_set.create(choice_text="Just hacking again", votes=0)

# Choice objects have API access to their related Question objects.
>>> c.question
<Question: What's up?>

# And vice versa: Question objects get access to Choice objects.
>>> q.choice_set.all()
<QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>
>>> q.choice_set.count()
3

# The API automatically follows relationships as far as you need.
# Use double underscores to separate relationships.
# This works as many levels deep as you want; there's no limit.
# Find all Choices for any question whose pub_date is in this year
# (reusing the 'current_year' variable we created above).
>>> Choice.objects.filter(question__pub_date__year=current_year)
<QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>

# Let's delete one of the choices. Use delete() for that.
>>> c = q.choice_set.filter(choice_text__startswith="Just hacking")
>>> c.delete()
~~~

### Presentando Django Admin.

Primero necesitamos crear un usuario para el sitio de administración. Ejecutamos:

~~~
python manage.py createsuperuser
~~~

Iniciamos el servidor de desarrollo:

~~~
python manage.py runserver
~~~

Abrimos un navegador web y vamos a http://127.0.0.1:8000/admin. Deberíamos ver la pantalla de inicio de sesión del administrador.

Iniciamos sesión con la cuenta de superusuario que creamos anteriormente.

Debemos hacer que nuestra aplicación de encuentas sea modificable en el administrador, para ello vamos a **polls/admin.py** y editamos lo siguiente:

~~~
from django.contrib import admin

from .models import Question

admin.site.register(Question)
~~~

Ahora que lo hemos registrado, Django sabe que debe mostrarse en la página de índice de la administración.