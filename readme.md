# Primera aplicación con Django

## Parte 1: Solicitudes y respuestas.

Para comprobar que Django está instalado y que versión ejecutando:

~~~
python -m django --version 
~~~

### Creando un proyecto.

~~~
django-admin startproject mysite
~~~

Esto creará el directorio/proyecto mysite en la ruta que nos encontremos.

### El servidor de desarrollo.

Verificamos que el proyecto Django funciona desde el directorio raíz:

~~~
python manage.py runserver
~~~

Visitamos http://127.0.0.1:8000 para comprobarlo.

### Creando la aplicación Encuestas.

Para crear la aplicación, nos aseguramos de estar en el mismo directorio que **manage.py** y ejecutamos:

~~~
python manage.py startapp polls
~~~

#### Nuestra primera vista.

Abrimos el archivo **polls/views.py** y colocamos el siguiente código:

~~~
from django.http import HttpResponse


def index(request):
    return HttpResponse("Hello, world. You're at the polls index.")
~~~

Debemos asignarla a una URL, y para esto necesitamos una URLconf. En el directorio polls, creamos un nuevo archivo llamado **urls.py** que incluirá el siguiente código:

~~~
from django.urls import path

from . import views

urlpatterns = [
    path("", views.index, name="index"),
]
~~~

El siguiente paso es apuntar la raíz URLconf al **polls/urls.py**. En **mysite/urls.py**, importamos include e insertamos include() en la urlpatterns, por lo que tenemos:

~~~
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path("polls/", include("polls.urls")),
    path("admin/", admin.site.urls),
]
~~~

Iniciamos el servidor y accedemos a http://localhost:8000/polls. Deberíamos ver el texto ("Hola, mundo") que definimos en la vista anterior.

## Parte 2: Modelos y el sitio de administración.

### Configuración de la base de datos.

Abrimos **mysite/settings.py**. De forma predeterminada, la configuración utiliza SQLite. Establecemos nuestra zona horaria a:

~~~
TIME_ZONE = 'Atlantic/Canary'
~~~

**INSTALLED_APPS** contiene los nombres de todas las aplicaciones que están activadas en esta instancia de Django.

Algunas de estas aplicaciones utilizan al menos una tabla de la base de datos, por lo que debemos crearlas antes de poder usarlas. Ejecutamos el siguiente comando:

~~~
python manage.py migrate
~~~

### Creando modelos.

En nuestra aplicación de encuentas, crearemos dos modelos: **Question** y **Choice**. Editamos el **polls/models.py**:

~~~
from django.db import models


class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField("date published")


class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)
~~~

### Activando modelos.

Para incluir la aplicación 'polls' a nuestro proyecto debemos agregar una referencia. Editamos **mysite/settings.py** y añadimos la ruta punteada en **INSTALLED_APPS**. Se verá tal que así:

~~~
INSTALLED_APPS = [
    "polls.apps.PollsConfig",
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
]
~~~

Ejecutamos otro comando:

~~~
python manage.py makemigrations polls
~~~

Deberíamos ver algo similar a lo siguiente:

~~~
Migrations for 'polls':
  polls/migrations/0001_initial.py
    - Create model Question
    - Create model Choice
~~~

Al ejecutar makemigrations, le estamos diciendo a Django que hemos realizado algunos cambios en sus modelos (en este caso, hemos realizado otros nuevos) y que desea que los cambios se almacenen como una migración.

El comando sqlmigrate toma nombres de migración y devuelve su SQL:

~~~
python manage.py sqlmigrate polls 0001
~~~

Deberíamos ver algo similar a lo siguiente:

~~~
BEGIN;
--
-- Create model Question
--
CREATE TABLE "polls_question" (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "question_text" varchar(200) NOT NULL,
    "pub_date" timestamp with time zone NOT NULL
);
--
-- Create model Choice
--
CREATE TABLE "polls_choice" (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "choice_text" varchar(200) NOT NULL,
    "votes" integer NOT NULL,
    "question_id" bigint NOT NULL
);
ALTER TABLE "polls_choice"
  ADD CONSTRAINT "polls_choice_question_id_c5b4b260_fk_polls_question_id"
    FOREIGN KEY ("question_id")
    REFERENCES "polls_question" ("id")
    DEFERRABLE INITIALLY DEFERRED;
CREATE INDEX "polls_choice_question_id_c5b4b260" ON "polls_choice" ("question_id");

COMMIT;
~~~

Ahora, volvemos a ejecutar migrate para crear las tablas modelo en la base de datos:

~~~
python manage.py migrate
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, polls, sessions
Running migrations:
  Rendering model states... DONE
  Applying polls.0001_initial... OK
~~~

Resumen de los tres pasos para realizar cambios en el modelo:
- Cambios en los modelos (en **models.py**).
- Ejecutar para crear migraciones para esos cambios **python manage.py makemigrations**
- Ejecutar para aplicar esos cambios a la base de datos **python manage.py migrate**

### Jugando con la API.

Invocamos el shell de Python:

~~~
python manage.py shell
~~~

~~~
>>> from polls.models import Choice, Question  # Import the model classes we just wrote.

# No questions are in the system yet.
>>> Question.objects.all()
<QuerySet []>

# Create a new Question.
# Support for time zones is enabled in the default settings file, so
# Django expects a datetime with tzinfo for pub_date. Use timezone.now()
# instead of datetime.datetime.now() and it will do the right thing.
>>> from django.utils import timezone
>>> q = Question(question_text="What's new?", pub_date=timezone.now())

# Save the object into the database. You have to call save() explicitly.
>>> q.save()

# Now it has an ID.
>>> q.id
1

# Access model field values via Python attributes.
>>> q.question_text
"What's new?"
>>> q.pub_date
datetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=datetime.timezone.utc)

# Change values by changing the attributes, then calling save().
>>> q.question_text = "What's up?"
>>> q.save()

# objects.all() displays all the questions in the database.
>>> Question.objects.all()
<QuerySet [<Question: Question object (1)>]>
~~~

No es una representación útil de este objeto. Editaremos el modelo y agregaremos un método a ambos en **polls/models.py**:

~~~
from django.db import models


class Question(models.Model):
    # ...
    def __str__(self):
        return self.question_text


class Choice(models.Model):
    # ...
    def __str__(self):
        return self.choice_text
~~~

Agregamos también un método personalizado a este modelo:

~~~
import datetime

from django.db import models
from django.utils import timezone


class Question(models.Model):
    # ...
    def was_published_recently(self):
        return self.pub_date >= timezone.now() - datetime.timedelta(days=1)
~~~

Guardamos los cambios e iniciamos un nuevo shell:

~~~
>>> from polls.models import Choice, Question

# Make sure our __str__() addition worked.
>>> Question.objects.all()
<QuerySet [<Question: What's up?>]>

# Django provides a rich database lookup API that's entirely driven by
# keyword arguments.
>>> Question.objects.filter(id=1)
<QuerySet [<Question: What's up?>]>
>>> Question.objects.filter(question_text__startswith="What")
<QuerySet [<Question: What's up?>]>

# Get the question that was published this year.
>>> from django.utils import timezone
>>> current_year = timezone.now().year
>>> Question.objects.get(pub_date__year=current_year)
<Question: What's up?>

# Request an ID that doesn't exist, this will raise an exception.
>>> Question.objects.get(id=2)
Traceback (most recent call last):
    ...
DoesNotExist: Question matching query does not exist.

# Lookup by a primary key is the most common case, so Django provides a
# shortcut for primary-key exact lookups.
# The following is identical to Question.objects.get(id=1).
>>> Question.objects.get(pk=1)
<Question: What's up?>

# Make sure our custom method worked.
>>> q = Question.objects.get(pk=1)
>>> q.was_published_recently()
True

# Give the Question a couple of Choices. The create call constructs a new
# Choice object, does the INSERT statement, adds the choice to the set
# of available choices and returns the new Choice object. Django creates
# a set to hold the "other side" of a ForeignKey relation
# (e.g. a question's choice) which can be accessed via the API.
>>> q = Question.objects.get(pk=1)

# Display any choices from the related object set -- none so far.
>>> q.choice_set.all()
<QuerySet []>

# Create three choices.
>>> q.choice_set.create(choice_text="Not much", votes=0)
<Choice: Not much>
>>> q.choice_set.create(choice_text="The sky", votes=0)
<Choice: The sky>
>>> c = q.choice_set.create(choice_text="Just hacking again", votes=0)

# Choice objects have API access to their related Question objects.
>>> c.question
<Question: What's up?>

# And vice versa: Question objects get access to Choice objects.
>>> q.choice_set.all()
<QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>
>>> q.choice_set.count()
3

# The API automatically follows relationships as far as you need.
# Use double underscores to separate relationships.
# This works as many levels deep as you want; there's no limit.
# Find all Choices for any question whose pub_date is in this year
# (reusing the 'current_year' variable we created above).
>>> Choice.objects.filter(question__pub_date__year=current_year)
<QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>

# Let's delete one of the choices. Use delete() for that.
>>> c = q.choice_set.filter(choice_text__startswith="Just hacking")
>>> c.delete()
~~~

### Presentando Django Admin.

Primero necesitamos crear un usuario para el sitio de administración. Ejecutamos:

~~~
python manage.py createsuperuser
~~~

Iniciamos el servidor de desarrollo:

~~~
python manage.py runserver
~~~

Abrimos un navegador web y vamos a http://127.0.0.1:8000/admin. Deberíamos ver la pantalla de inicio de sesión del administrador.

Iniciamos sesión con la cuenta de superusuario que creamos anteriormente.

Debemos hacer que nuestra aplicación de encuentas sea modificable en el administrador, para ello vamos a **polls/admin.py** y editamos lo siguiente:

~~~
from django.contrib import admin

from .models import Question

admin.site.register(Question)
~~~

Ahora que lo hemos registrado, Django sabe que debe mostrarse en la página de índice de la administración.

## Parte 3: Vistas y plantillas.

### Escribiendo más vistas.

Agregamos algunas vistas más en **polls/views.py**:

~~~
def detail(request, question_id):
    return HttpResponse("You're looking at question %s." % question_id)


def results(request, question_id):
    response = "You're looking at the results of question %s."
    return HttpResponse(response % question_id)


def vote(request, question_id):
    return HttpResponse("You're voting on question %s." % question_id)
~~~

Conectamos las vistas al **polls.urls** agregando las siguientes path():

~~~
from django.urls import path

from . import views

urlpatterns = [
    # ex: /polls/
    path("", views.index, name="index"),
    # ex: /polls/5/
    path("<int:question_id>/", views.detail, name="detail"),
    # ex: /polls/5/results/
    path("<int:question_id>/results/", views.results, name="results"),
    # ex: /polls/5/vote/
    path("<int:question_id>/vote/", views.vote, name="vote"),
]
~~~

### Escribir vistas que realmente hagan algo.

Todo lo que Django quiere es un HttpResponse, o una excepción.

Mostramos las últimas 5 preguntas de la encuesta en el sistema, separadas por comas, según la fecha de publicación:

~~~
from django.http import HttpResponse

from .models import Question


def index(request):
    latest_question_list = Question.objects.order_by("-pub_date")[:5]
    output = ", ".join([q.question_text for q in latest_question_list])
    return HttpResponse(output)


# Leave the rest of the views (detail, results, vote) unchanged
~~~

Crearemos un directorio llamado templates dentro del directorio polls. Dentro de templates, otro directorio llamado polls y dentro un archivo llamado index.html con el siguiente código:

~~~
{% if latest_question_list %}
    <ul>
    {% for question in latest_question_list %}
        <li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
    {% endfor %}
    </ul>
{% else %}
    <p>No polls are available.</p>
{% endif %}
~~~

Actualizamos nuestra vista index **polls/views.py** para usar la plantilla:

~~~
from django.http import HttpResponse
from django.template import loader

from .models import Question


def index(request):
    latest_question_list = Question.objects.order_by("-pub_date")[:5]
    template = loader.get_template("polls/index.html")
    context = {
        "latest_question_list": latest_question_list,
    }
    return HttpResponse(template.render(context, request))
~~~

### El atajo render().

Es un modismo muy común cargar una plantilla, llenar un contexto y devolver un HttpResponse con el resultado de la plantilla renderizada. Django proporciona un atajo. Aquí está la vista index() completa, reescrita:

~~~
from django.shortcuts import render

from .models import Question


def index(request):
    latest_question_list = Question.objects.order_by("-pub_date")[:5]
    context = {"latest_question_list": latest_question_list}
    return render(request, "polls/index.html", context)
~~~

### Generando un error 404.

Abordaremos ahora la vista details de la pregunta. Aquí la vista:

~~~
from django.http import Http404
from django.shortcuts import render

from .models import Question


# ...
def detail(request, question_id):
    try:
        question = Question.objects.get(pk=question_id)
    except Question.DoesNotExist:
        raise Http404("Question does not exist")
    return render(request, "polls/detail.html", {"question": question})
~~~

Si deseamos que el ejemplo anterior funcione rápidamente, crearemos el archivo **detail.html** que contendrá sólo:

~~~
{{ question }}
~~~

### El atajo get_object_or_404().

Es un modismo muy común para usar get() y plantear Http404 si el objeto no existe. Django proporciona un atajo. Aquí está la vista detail(), reescrita:

~~~
from django.shortcuts import get_object_or_404, render

from .models import Question


# ...
def detail(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    return render(request, "polls/detail.html", {"question": question})
~~~

### Usar el sistema de plantillas.

Así se vería la plantilla **detail.html**:

~~~
<h1>{{ question.question_text }}</h1>
<ul>
{% for choice in question.choice_set.all %}
    <li>{{ choice.choice_text }}</li>
{% endfor %}
</ul>
~~~

### Eliminación de URL codificadas en plantillas.

Cuando escribimos el enlace a una pregunta en la plantilla **polls/index.html**, el enlace estaba parcialmente codificado de esta manera:

~~~
<li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
~~~

Sin embargo, dado que definimos el argumento de nombre en las funciones path() del módulo polls.urls, podemos eliminar la dependencia de rutas de URL específicas definidas en sus configuraciones de URL utilizando la etiqueta de plantilla:{% url %}

~~~
<li><a href="{% url 'detail' question.id %}">{{ question.question_text }}</a></li>
~~~

### Nombres de URL de espacio de nombres.

En el archivo **polls/urls.py**, agregamos un app_name para configurar el espacio de nombres de la aplicación:

~~~
from django.urls import path

from . import views

app_name = "polls"
urlpatterns = [
    path("", views.index, name="index"),
    path("<int:question_id>/", views.detail, name="detail"),
    path("<int:question_id>/results/", views.results, name="results"),
    path("<int:question_id>/vote/", views.vote, name="vote"),
]
~~~

Ahora editamos la plantilla **polls/index.html** a:

~~~
<li><a href="{% url 'polls:detail' question.id %}">{{ question.question_text }}</a></li>
~~~

## Parte 4: Formularios y vistas genéricas.

### Escribe un formulario.

Actualizamos nuestra plantilla **polls/detail.html** para que contenga el siguiente formulario:

~~~
<form action="{% url 'polls:vote' question.id %}" method="post">
{% csrf_token %}
<fieldset>
    <legend><h1>{{ question.question_text }}</h1></legend>
    {% if error_message %}<p><strong>{{ error_message }}</strong></p>{% endif %}
    {% for choice in question.choice_set.all %}
        <input type="radio" name="choice" id="choice{{ forloop.counter }}" value="{{ choice.id }}">
        <label for="choice{{ forloop.counter }}">{{ choice.choice_text }}</label><br>
    {% endfor %}
</fieldset>
<input type="submit" value="Vote">
</form>
~~~

Ahora, crearemos una vista de Django que maneje los datos enviados y haga algo con ellos. También crearemos la función vote(). Agregamos lo siguiente a **polls/views.py**:

~~~
from django.http import HttpResponse, HttpResponseRedirect
from django.shortcuts import get_object_or_404, render
from django.urls import reverse

from .models import Choice, Question


# ...
def vote(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    try:
        selected_choice = question.choice_set.get(pk=request.POST["choice"])
    except (KeyError, Choice.DoesNotExist):
        # Redisplay the question voting form.
        return render(
            request,
            "polls/detail.html",
            {
                "question": question,
                "error_message": "You didn't select a choice.",
            },
        )
    else:
        selected_choice.votes += 1
        selected_choice.save()
        # Always return an HttpResponseRedirect after successfully dealing
        # with POST data. This prevents data from being posted twice if a
        # user hits the Back button.
        return HttpResponseRedirect(reverse("polls:results", args=(question.id,)))
~~~

Después de que alguien vota en una pregunta, vote() redirige a la página de resultados de la pregunta. Escribimos esa vista:

~~~
from django.shortcuts import get_object_or_404, render


def results(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    return render(request, "polls/results.html", {"question": question})
~~~

Ahora, creamos la plantilla **polls/results.html**:

~~~
<h1>{{ question.question_text }}</h1>

<ul>
{% for choice in question.choice_set.all %}
    <li>{{ choice.choice_text }} -- {{ choice.votes }} vote{{ choice.votes|pluralize }}</li>
{% endfor %}
</ul>

<a href="{% url 'polls:detail' question.id %}">Vote again?</a>
~~~

Ahora, vamos a /polls/1/ en el navegador y votamos en la pregunta. Deberíamos ver una página de resultados que se actualiza cada vez que vota. Si enviamos el formulario sin haber elegido una opción, deberíamos ver el mensaje de error.

### Usar vistas genéricas: Menos código es mejor.

Convertiremos nuestra aplicación de encuestas para usar el sistema de vistas genéricas, de modo que podamos eliminar un montón de nuestro propio código. Tendremos que dar algunos pasos para hacer la conversión. Haremos lo siguiente:

- Convertimos la URLconf.
- Eliminamos algunas de las vistas antiguas e innecesarias.
- Introducimos nuevas vistas basadas en las vistas genéricas de Django.

### Modificar URLconf.

Abrimos **polls/urls.py** y modificamos:

~~~
from django.urls import path

from . import views

app_name = "polls"
urlpatterns = [
    path("", views.IndexView.as_view(), name="index"),
    path("<int:pk>/", views.DetailView.as_view(), name="detail"),
    path("<int:pk>/results/", views.ResultsView.as_view(), name="results"),
    path("<int:question_id>/vote/", views.vote, name="vote"),
]
~~~

### Modificar vistas.

A continuación, eliminamos nuestras antiguas vistas index, detail y results. Usaremos las vistas genéricas de Django en su lugar. Para hacerlo, abrimos el **polls/views.py**  y cambiamos lo siguiente:

~~~
from django.http import HttpResponseRedirect
from django.shortcuts import get_object_or_404, render
from django.urls import reverse
from django.views import generic

from .models import Choice, Question


class IndexView(generic.ListView):
    template_name = "polls/index.html"
    context_object_name = "latest_question_list"

    def get_queryset(self):
        """Return the last five published questions."""
        return Question.objects.order_by("-pub_date")[:5]


class DetailView(generic.DetailView):
    model = Question
    template_name = "polls/detail.html"


class ResultsView(generic.DetailView):
    model = Question
    template_name = "polls/results.html"


def vote(request, question_id):
    ...  # same as above, no changes needed.
~~~

Estamos usando dos vistas genéricas: ListViewy DetailView. Respectivamente, esas dos vistas resumen los conceptos de "mostrar una lista de objetos" y "mostrar una página de detalles para un tipo particular de objeto".

## Parte 5: Pruebas.

### ¿Qué son las pruebas automatizadas?.
Las pruebas son rutinas que comprueban el funcionamiento de su código.

### ¿Por qué necesitamos crear pruebas?.
- Te ahorrarán tiempo.
- No solo identifican problemas, los previenen.
- Hacen que el código sea más atractivo.
- Ayudan a los equipos a trabajar juntos.

### Escribiendo nuestra primera prueba.

- Identificamos un error:

Afortunadamente, hay un pequeño error en la aplicación polls que debemos solucionar de inmediato: el método Question.was_published_recently() devuelve True si Question publicó dentro del último día (lo cual es correcto), pero también si el campo Question's pub_date está en el futuro (que ciertamente no lo es).

Confirmamos el error utilizando shell:

~~~
python manage.py shell

>>> import datetime
>>> from django.utils import timezone
>>> from polls.models import Question
>>> # create a Question instance with pub_date 30 days in the future
>>> future_question = Question(pub_date=timezone.now() + datetime.timedelta(days=30))
>>> # was it published recently?
>>> future_question.was_published_recently()
True
~~~

Dado que las cosas en el futuro no son 'recientes', esto es claramente erróneo.

- Creamos una prueba para exponer el error:

Ponemos lo siguiente en el **polls/tests.py**:

~~~
import datetime

from django.test import TestCase
from django.utils import timezone

from .models import Question


class QuestionModelTests(TestCase):
    def test_was_published_recently_with_future_question(self):
        """
        was_published_recently() returns False for questions whose pub_date
        is in the future.
        """
        time = timezone.now() + datetime.timedelta(days=30)
        future_question = Question(pub_date=time)
        self.assertIs(future_question.was_published_recently(), False)
~~~

- Ejecutando pruebas:

~~~
python manage.py test polls

Creating test database for alias 'default'...
System check identified no issues (0 silenced).
F
======================================================================
FAIL: test_was_published_recently_with_future_question (polls.tests.QuestionModelTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/path/to/mysite/polls/tests.py", line 16, in test_was_published_recently_with_future_question
    self.assertIs(future_question.was_published_recently(), False)
AssertionError: True is not False

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
Destroying test database for alias 'default'...
~~~

- Arreglando el error:

Modificamos el método en **models.py**, para que solo regrese True si la fecha también está en el pasado:

~~~
def was_published_recently(self):
    now = timezone.now()
    return now - datetime.timedelta(days=1) <= self.pub_date <= now
~~~

Ejecutamos la prueba de nuevo:

~~~
python manage.py test polls

Creating test database for alias 'default'...
System check identified no issues (0 silenced).
.
----------------------------------------------------------------------
Ran 1 test in 0.001s

OK
Destroying test database for alias 'default'...
~~~

### Pruebas más complejas.

Agregamos dos métodos de prueba más a la misma clase:

~~~
def test_was_published_recently_with_old_question(self):
    """
    was_published_recently() returns False for questions whose pub_date
    is older than 1 day.
    """
    time = timezone.now() - datetime.timedelta(days=1, seconds=1)
    old_question = Question(pub_date=time)
    self.assertIs(old_question.was_published_recently(), False)


def test_was_published_recently_with_recent_question(self):
    """
    was_published_recently() returns True for questions whose pub_date
    is within the last day.
    """
    time = timezone.now() - datetime.timedelta(hours=23, minutes=59, seconds=59)
    recent_question = Question(pub_date=time)
    self.assertIs(recent_question.was_published_recently(), True)
~~~

Ahora tenemos tres pruebas que confirman que Question.was_published_recently() arroja valores sensibles para preguntas pasadas, recientes y futuras.

### Probar una vista.

La aplicación de encuestas es bastante indiscriminada: publicará cualquier pregunta, incluidas aquellas cuyo campo pub_date se encuentre en el futuro. Deberíamos mejorar esto. Establecer a pub_date en el futuro debería significar que la pregunta se publica en ese momento, pero invisible hasta entonces.

### El cliente de prueba de Django.

Django proporciona una prueba **Client** para simular la interacción de un usuario con el código en el nivel de vista. Podemos usarlo en **tests.py** o incluso en el shell.

~~~
python manage.py shell

>>> from django.test.utils import setup_test_environment
>>> setup_test_environment()
~~~

A continuación, debemos importar la clase de cliente de prueba:

~~~
>>> from django.test import Client
>>> # create an instance of the client for our use
>>> client = Client()
~~~

Con eso listo, podemos pedirle al cliente que haga el trabajo por nosotros:

~~~
>>> # get a response from '/'
>>> response = client.get("/")
Not Found: /
>>> # we should expect a 404 from that address; if you instead see an
>>> # "Invalid HTTP_HOST header" error and a 400 response, you probably
>>> # omitted the setup_test_environment() call described earlier.
>>> response.status_code
404
>>> # on the other hand we should expect to find something at '/polls/'
>>> # we'll use 'reverse()' rather than a hardcoded URL
>>> from django.urls import reverse
>>> response = client.get(reverse("polls:index"))
>>> response.status_code
200
>>> response.content
b'\n    <ul>\n    \n        <li><a href="/polls/1/">What&#x27;s up?</a></li>\n    \n    </ul>\n\n'
>>> response.context["latest_question_list"]
<QuerySet [<Question: What's up?>]>
~~~

### Mejorando nuestra vista.

Necesitamos modificar en **polls/views.py** el método get_queryset() de la clase **IndexView** y cambiarlo para que también verifique la fecha comparándola con timezone.now().

~~~
from django.utils import timezone

def get_queryset(self):
    """
    Return the last five published questions (not including those set to be
    published in the future).
    """
    return Question.objects.filter(pub_date__lte=timezone.now()).order_by("-pub_date")[
        :5
    ]
~~~

### Probando nuestra vista.

Agregamos lo siguiente a **polls/test.py**:

~~~
from django.urls import reverse

def create_question(question_text, days):
    """
    Create a question with the given `question_text` and published the
    given number of `days` offset to now (negative for questions published
    in the past, positive for questions that have yet to be published).
    """
    time = timezone.now() + datetime.timedelta(days=days)
    return Question.objects.create(question_text=question_text, pub_date=time)


class QuestionIndexViewTests(TestCase):
    def test_no_questions(self):
        """
        If no questions exist, an appropriate message is displayed.
        """
        response = self.client.get(reverse("polls:index"))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, "No polls are available.")
        self.assertQuerySetEqual(response.context["latest_question_list"], [])

    def test_past_question(self):
        """
        Questions with a pub_date in the past are displayed on the
        index page.
        """
        question = create_question(question_text="Past question.", days=-30)
        response = self.client.get(reverse("polls:index"))
        self.assertQuerySetEqual(
            response.context["latest_question_list"],
            [question],
        )

    def test_future_question(self):
        """
        Questions with a pub_date in the future aren't displayed on
        the index page.
        """
        create_question(question_text="Future question.", days=30)
        response = self.client.get(reverse("polls:index"))
        self.assertContains(response, "No polls are available.")
        self.assertQuerySetEqual(response.context["latest_question_list"], [])

    def test_future_question_and_past_question(self):
        """
        Even if both past and future questions exist, only past questions
        are displayed.
        """
        question = create_question(question_text="Past question.", days=-30)
        create_question(question_text="Future question.", days=30)
        response = self.client.get(reverse("polls:index"))
        self.assertQuerySetEqual(
            response.context["latest_question_list"],
            [question],
        )

    def test_two_past_questions(self):
        """
        The questions index page may display multiple questions.
        """
        question1 = create_question(question_text="Past question 1.", days=-30)
        question2 = create_question(question_text="Past question 2.", days=-5)
        response = self.client.get(reverse("polls:index"))
        self.assertQuerySetEqual(
            response.context["latest_question_list"],
            [question2, question1],
        )
~~~

### Probando DetailView.

Lo que tenemos funciona bien; sin embargo, aunque las preguntas futuras no aparecen en el índice, los usuarios aún pueden comunicarse con ellas si saben o adivinan la URL correcta. Entonces necesitamos agregar una restricción similar a DetailView:

~~~
class DetailView(generic.DetailView):
    ...

    def get_queryset(self):
        """
        Excludes any questions that aren't published yet.
        """
        return Question.objects.filter(pub_date__lte=timezone.now())

class QuestionDetailViewTests(TestCase):
    def test_future_question(self):
        """
        The detail view of a question with a pub_date in the future
        returns a 404 not found.
        """
        future_question = create_question(question_text="Future question.", days=5)
        url = reverse("polls:detail", args=(future_question.id,))
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    def test_past_question(self):
        """
        The detail view of a question with a pub_date in the past
        displays the question's text.
        """
        past_question = create_question(question_text="Past Question.", days=-5)
        url = reverse("polls:detail", args=(past_question.id,))
        response = self.client.get(url)
        self.assertContains(response, past_question.question_text)
~~~

### Al probar, más es mejor.

Siempre que sus pruebas se organicen con sensatez, no se volverán inmanejables. Las buenas reglas generales incluyen tener:

- Una TestClass separada para cada modelo o vista.
- Un método de prueba separado para cada conjunto de condiciones que desea probar.
- Nombres de métodos de prueba que describen su función.

## Parte 6: Archivos estáticos.

### Personalizamos la apariencia de la aplicación.

Primero, creamos un directorio llamado static en polls. Django buscará archivos estáticos allí, de manera similar a como Django encuentra plantillas dentro de polls/templates/.

Dentro del directorio static que acabamos de crear, creamos otro directorio llamado polls y dentro de ese creamos un archivo llamado style.css. En otras palabras, nuestra hoja de estilo debe estar en **polls/static/polls/style.css**.

Ponemos el siguiente código en la hoja de estilo:

~~~
li a {
    color: green;
}
~~~

A continuación, agregamos lo siguiente en la parte superior de **polls/templates/polls/index.html**:

~~~
{% load static %}

<link rel="stylesheet" href="{% static 'polls/style.css' %}">
~~~

Iniciamos el servidor, volvemos a cargar **http://localhost:8000/polls/** y deberíamos ver que los enlaces de las preguntas son verdes, lo que significa que la hoja de estilo se cargó correctamente.

### Agregar una imagen de fondo.

Creamos un subdirectorio images en **polls/static/polls/**. Dentro de este directorio, agreguemos cualquier archivo de imagen que le gustaría usar como fondo. Para los propósitos de este tutorial, estamos usando un archivo llamado background.png, que tendrá como ruta absoluta polls/static/polls/images/background.png.

Luego, agregamos la referencia a la imagen en la hoja de estilo (**polls/static/polls/style.css**):

~~~
body {
    background: white url("images/background.png") no-repeat;
}
~~~

Volvemos a cargar **http://localhost:8000/polls/** y deberíamos de ver el fondo cargado.